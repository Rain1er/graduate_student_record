## 2025-9 论文学习

## 1. Where URLs Become Weapons Automated Discovery of SSRF Vulnerabilities in Web Applications

Challenge 1: Lack of an oracle to identify all sinks related to SSRF vulnerability

Challenge 2: Reducing the input space for fuzzing

Challenge 3: Generating effective payloads to trigger SSRF vulnerabilities.

大概三大类：SSRF sink未完全覆盖，如何减小**输入空间**（定位有效source），如何生成包含绕过的**有效payload**。

C1的解决方案：从php手册生成2101个函数的测试用例，With these test cases, the SSRF oracle-based picker filters out sensitive sinks that could lead to SSRF vulnerability.这里他说使用GPT3.5实现。

C2的解决方案：动态污点推理（Hook SSRF sink，记录用户输入的参数），即寻找sink对应的source，以便**缩小输入范围**。

C3的解决方案：

1. http OOB

2. DNS OOB

3. port listen

4. 文件回显检测、如file:///etc/passwd

**文件监控策略，部署在服务端**

5. 服务端HTTP请求日志中是否含有字符串的url

6. 检查Web应用程序是否与特定文件有过交互，Linux下可以使用strace监控/etc/passw相关的系统调用

SSRFuzz原型：crawlergo递归搜索路径，自动提交表单和智能js事件，并且模拟交互。

hook SSRFsink 通过修改Zend虚拟机实现。

## 2. effective Directed Fuzzing with Hierarchical Scheduling for Web Vulnerability

> 检测 Java Web 应用中命令注入、SQL 注入、任意文件读写等 6 类常见高危漏洞。
> 
> 可利用定向模糊测试来缩小待分析的代码空间。要实现这一目标，关键在于引导模糊测试聚焦于连接用户输入（通过入口点）与敏感操作的关键路径。其次，我们观察到，由于应用程序不同部分所采用的输入验证、净化和处理逻辑存在差异，不同 Web 入口点和 sink 位置（执行敏感操作的代码位置）触发漏洞的难度也各不相同。这种差异促使我们设计一种新颖的分层调度策略，将测试资源优先分配给最具潜力的路径，从而最大限度地提高漏洞成功利用的可能性。

这篇和上一篇有一个相同的地方，即缩小待分析的代码空间。推翻了我之前用程序覆盖率引导的思路。

1）静态准备阶段，该阶段理解并提取必要的语义信息，包括通往 sink 的敏感路径和路径约束，为后续的模糊测试提供引导；

2）动态模糊测试阶段，该阶段采用分层调度策略对路径进行探索。

Challenge-1: Exploring numerous web entries and parameters with low throughput.

Challenge-2: Generating structured and semantically constrained inputs to test web parameters.

**如何减小输入空间（定位有效source），如何生成包含有效格式的payload。**

## 3. LLMxCPG Context-Aware Vulnerability Detection Through Code Property Graph Guided LLM

> LLMxCPG：基于代码属性图引导的大型语言模型实现上下文感知漏洞检测

代码属性图（CPG）、CPGQL、深度学习、微调看不懂，后面需要专门学习这部分内容。

## 4. xssky-usenixsecurity25-shi-youkun

> 反射型服务器端 XSS 漏洞

将sink-source路径转换为可本地执行的代码片段

挑战一：如何可靠地将静态工具报告的路径转换为可执行 PUT？

挑战二：如何通过模糊测试 PUT 高效检测 XSS 漏洞？

## 5. bytebuddy字节码修改框架

HookAgent.java

```java
class HookAgent {
    // 启动时注入入口，在JVM启动参数中加入 -javaagent:agent.jar
    public static void premain(String agentArgs, Instrumentation instrumentation) {
        System.out.println("[Agent] premain called with args: " + agentArgs);
        init(agentArgs, instrumentation);
    }

    // 运行时 attach 入口，配合 ByteBuddyAgent.attach 使用
    public static void agentmain(String agentArgs, Instrumentation instrumentation) {
        System.out.println("[Agent] agentmain called with args: " + agentArgs);
//        System.out.println(instrumentation.isRetransformClassesSupported());
        init(agentArgs, instrumentation);
    }

    /**
     * 公共初始化逻辑，premain/agentmain 都会调用
     */
    private static void init(String agentArgs, Instrumentation instrumentation) {
        new AgentBuilder.Default()
                .with(AgentBuilder.InjectionStrategy.UsingUnsafe.INSTANCE)// 避免因为类加载器隔离导致偶发失败，尤其是在多应用、多模块的 Tomcat 部署中
                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                .disableClassFormatChanges()
                .type(ElementMatchers.nameStartsWith("com.rain.pojo.User"))
                .transform((builder, td, cl, jm, pd) -> builder.method(named("getAge")).intercept(FixedValue.value("hooked!")))
                .installOn(instrumentation);

    }
}
```

Main.java

```java
public class Main {
    public static void main(String[] args) {
        try {
            // 执行 jps -l 命令，如果这里环境变量不存在。那么手动执行/path/to/jdk/bin/jps -l
            Process process = Runtime.getRuntime().exec("jps -l");
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            System.out.println("可用的 JVM 进程：");
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }

            // 用户选择 PID
            Scanner scanner = new Scanner(System.in);
            System.out.print("请输入要 hook 的 JVM PID：");
            String pid = scanner.nextLine();

            // 用户输入 agent 路径
            System.out.print("请输入 agent 的路径：");
            String agentPath = scanner.nextLine();
            File agentJar = new File(agentPath);

            // Attach agent
            ByteBuddyAgent.attach(agentJar, pid);
            System.out.println("Agent 已附加到进程 " + pid);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
