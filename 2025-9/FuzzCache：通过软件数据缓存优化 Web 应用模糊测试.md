# FuzzCache：通过软件数据缓存优化 Web 应用模糊测试

> Title: FuzzCache: Optimizing Web Application Fuzzing Through Software-Based Data Cache
>
> Conference: In Proceedings of The 31st ACM Conference on Computer and Communications Security (CCS), October 2024.
>
> PDF: https://zhangmx1997.github.io/papers/ccs24_fuzzcache.pdf
>
> Artifact: https://github.com/secureweb/fuzzcache

​	该文章提出了一种针对 Web 应用模糊测试的创新软件数据缓存机制，核心是通过缓存重复的数据库查询和网络请求数据来提升测试效率。

​	其创新点在于敏锐的发现了"**重复数据获取**"造成webfuzz效率不高的问题，设计了以查询为中心的缓存策略（直接缓存 SQL 查询最终返回的业务数据），表级粒度的缓存失效机制（用 "脏位" 标记过期数据）、跨进程共享内存存储（突破 PHP 请求隔离限制），以及轻量级 SQL 语法检查器。并且有效集成了现有工具链，为安全测试工具的基础设施优化提供了可参考的思路。

## 1. 引言

​	模糊测试在检测服务器端Web应用程序的漏洞方面展现出了巨大潜力。该研究引入了一种创新的基于软件的数据缓存机制，它能对所有现有的Web应用程序模糊测试工具起到补充和改进作用。

​	核心观点是，Web应用程序很大一部分（例如50%）的执行时间都用于从两个主要来源获取数据：数据库和网络；且相同的数据往往会被反复获取。

​	因此，该研究提出了一种新的解决方案——FuzzCache，它将数据存储到基于软件的缓存中，减少了重复且代价高昂的数据获取需求。FuzzCache通过进程间共享内存段在不同的模糊测试试验中提供缓存数据。此外，作为首次尝试，它还融入了**即时编译JIT**技术，以避免实时解释PHP代码带来的性能开销，从而提高执行效率。

​	FuzzCache 显著提升了 Web 应用程序的模糊测试性能。在实验中，将 FuzzCache 与黑盒模糊测试工具（Black-Widow）和灰盒模糊测试工具（WebFuzz）都进行了集成。

​	结果表明，FuzzCache 加快了黑盒和灰盒模糊测试的速度，使吞吐量提升了 3 到 4 倍。代码覆盖率平均提升 25%。



## 2. 背景与动机

### 2.1 Web 应用与 PHP 生态

​	PHP 是构建 Web 应用的主流语言，其工作模式通常为每个请求分配一个独立进程。这保证了良好的隔离性，但也意味着数据库连接等资源无法在请求间复用。

​	PHP 的执行过程包括代码解析、编译为字节码（OPCode），最后由 Zend 引擎解释执行。OPCache 可以缓存字节码以避免重复解析，而 PHP 8 引入的 JIT 编译则能将热点字节码直接编译为机器码，进一步加速执行。

### 2.2 Web 应用模糊测试

​	模糊测试工具主要分为黑盒（如 Black-Widow）和灰盒（如 WebFuzz）两类。黑盒工具不依赖内部信息，通过注入随机负载并观察结果来发现漏洞；灰盒工具则通过插桩等方式获取代码覆盖率信息，以指导测试用例生成，效率通常更高。

### 2.3 核心动机：昂贵且重复的函数调用

<img src="https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250926171910407.png" alt="image-20250926171910407" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250926171851122.png" alt="image-20250926171851122" style="zoom:50%;" />

​	使用 XHProf 对常见web应用进行了函数级性能剖析，结果非常有启发性，主要集中在以下两个方面

1. **昂贵函数**：在 WordPress 中，`curl_exec` 和 `mysqli_query` 两个函数就消耗了超过 70% 的总执行时间。在 phpBB3 中，数据库查询函数同样是主要瓶颈。
2. **高度重复**：大量函数调用的参数和返回结果是完全相同的。我们观察到，约 68% 的数据库调用和 87% 的网络调用在不同请求中是重复的。

​	这种 “高成本” 与 “高重复” 并存的现象，构成了巨大的性能优化空间。直接移除这些调用会破坏应用逻辑，因此，**一个透明、高效的软件缓存层**成为了理想的解决方案。



## 3. 主要挑战

​	在 PHP 环境中实现这样的缓存系统面临四大核心挑战：

- **C1: 非持久化数据库连接**

  数据库操作通常分为连接、查询、获取结果等步骤。由于连接无法跨进程持久化，直接缓存中间结果对象（如`mysqli_result`）是不可行的。

- **C2: 缓存一致性与失效**

  当数据库数据被更新（如`UPDATE`）时，相关的缓存项必须被及时标记为失效，否则会导致测试基于陈旧数据，产生错误结果。如何精确、高效地管理失效是一大难题。

- **C3: 跨进程数据维护**

  由于 PHP 的请求隔离模型，常规的内存缓存（如 Memcached）无法在不同请求或测试用例间共享，导致缓存命中率极低。

- **C4: 与现有模糊测试工具的兼容性**

  某些先进的漏洞检测技术（如基于 SQL 语法错误的注入检测）依赖于实际执行 SQL 查询。如果查询被缓存跳过，这些漏洞将无法被检测到。



## 4. FuzzCache 的设计与实现

​	为应对上述挑战，FuzzCache 的设计围绕以下几个核心模块展开。

### 4.1 数据库数据缓存（解决C1）

​	FuzzCache 采用以查询为中心（Query-Centric）的缓存策略，其核心思想是缓存 SQL 查询最终返回的数据，而非包含活跃数据库连接的查询结果对象（如 mysqli_result），以此解决 PHP 环境下数据库连接无法跨请求持久化的问题。

​	为进一步优化性能，该策略还集成两项关键技术：

1. **延迟连接**（Lazy Connection），仅在缓存未命中时才按需建立数据库连接，避免无意义的连接开销；
2. **数据预取**（Data Prefetch），一旦执行查询便一次性提取所有结果数据并完整存入缓存，杜绝后续应用代码逐行读取带来的额外消耗。

​	在缓存结构设计上，每个缓存项均包含查询字符串的哈希值（作为索引）、对应的完整数据、查询所关联的数据库表名，以及用于标记数据有效性的 “脏位”（Dirty Bit），为后续缓存失效管理奠定基础。

​	下图展示了读取查询的工作流程

![image-20250925185622339](https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250925185622339.png)

### 4.2 缓存失效与一致性（解决 C2）

​	为高效维护缓存一致性，FuzzCache 采用表级粒度的失效策略：在缓存 `SELECT` 查询时，会先分析其 SQL 语句以提取操作的表名，并将这些表名与对应缓存项关联存储；当执行 `UPDATE`、`INSERT` 等写操作时，会识别出被修改的表，进而将所有与该表关联的缓存项的 “脏位” 设为 1（标记为脏）；后续读取缓存时，若检测到 “脏位” 为 1，则判定为缓存未命中，需重新从数据库获取数据并刷新缓存。

​	该策略无需复杂的行级依赖分析，在确保数据一致性的同时，实现了高效的缓存失效管理。

​	下图展示了其设计结构：

![image-20250925185944651](https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250925185944651.png)

### 4.3 跨进程共享内存（解决 C3）

​	为了让缓存能够在不同请求和测试用例间复用，FuzzCache 借鉴了 OPCache 的设计，利用 PHP 的**进程间共享内存**（Shared Memory） 来存储所有缓存数据。这使得缓存能够在整个模糊测试会话期间持续存在，有效解决了 PHP 环境下的缓存共享难题。



### 4.4 兼容性保障（解决 C4）

​	为了不影响依赖 SQL 解析错误的漏洞检测，FuzzCache 集成了一个**轻量级 SQL 语法检查器**。当一个查询到来时，会先经过语法检查。如果查询存在语法错误（这是 SQL 注入的典型特征），FuzzCache 会跳过缓存流程，让查询真实执行，确保漏洞能够被检测到。

## 5. 实验设置

​	为全面验证 FuzzCache 的有效性，实验从测试对象、评估工具、度量指标三个维度科学设计，确保结果可信度与普适性。测试对象选取三类具有代表性的 Web 应用：

1. 参考 Witcher 等研究构建的 5 个微测试用例（Microtests），每个脚本仅含基础数据库操作或网络请求，用于孤立验证缓存基础性能；

2. 经典基准漏洞测试套件 Damn Vulnerable Web Application（DVWA）和 buggy Web Application（bWAPP），二者包含人工注入的 XSS、SQL 注入等已知漏洞，可量化评估 FuzzCache 对漏洞检测能力的影响；

3. 6 个广泛部署的真实世界旧版本 Web 应用，包括 WordPress、phpBB3、OpenEMR 、WeBid、WackoPicko、Joomla，用于模拟真实测试场景下的性能表现。

​	所有应用均部署于 Ubuntu 22.04 容器（4GB 内存），搭载 Apache 2 与 PHP 8.2（启用 OPCache，JIT 配置为 “脚本加载时编译 + 全脚本优化”），MySQL 8.0 数据库按默认配置初始化，并为每个应用创建测试账号支持自动化身份验证。

​	评估工具选取两类代表性模糊测试工具以覆盖黑盒与灰盒场景：一是 Black-Widow（黑盒工具），采用数据驱动导航策略，无需源码即可模拟用户交互、注入测试 payload，专注检测存储型 XSS 漏洞；二是 WebFuzz（灰盒工具），需对应用源码插桩，通过追踪基础块覆盖率指导测试用例生成，同样以 XSS 漏洞为主要检测目标。

​	实验设置四组对比方案：原生 Black-Widow（BW）、集成 FuzzCache 的 Black-Widow（BW+）、原生 WebFuzz（WF）、集成 FuzzCache 的 WebFuzz（WF+），每组方案对每个测试对象执行 5 次独立实验，每次实验时长限制为 24 小时以排除随机因素影响。实验中各类工具在 24 小时内的代码覆盖率变化趋势如下。

![image-20250927152709994](https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250927152709994.png)

​	度量指标选取四类核心指标评估性能：

1. 代码覆盖率，通过 XDebug 采集基础块覆盖数据，计算 “被覆盖基础块数 / 总基础块数” 的比例，反映代码探索能力，结果取 5 次实验的几何平均值；

2. 吞吐量，统计单位时间内执行的测试用例数（用例 / 小时），反映测试效率，结果取算术平均值；

3. 漏洞检测数量，统计各组方案检测到的 unique 漏洞数（按漏洞所在 “sink 函数位置” 区分），重点关注 XSS 漏洞及 FuzzCache 额外检测的注入漏洞，结果取算术平均值；

4. 缓存性能，包括缓存命中率（`命中次数/(命中次数+未命中次数)`）与缓存峰值占用（实验期间共享内存最大使用量），评估缓存机制有效性与资源消耗。所有数据均通过自动化脚本采集，各类应用在不同方案下的具体性能数据可参考下表。

![image-20250927152625299](https://cdn.jsdelivr.net/gh/Rain1er/images@main/img/image-20250927152625299.png)

## 7. 小结

​	FuzzCache 特别适用于对数据库和网络 I/O 密集型的 PHP Web 应用进行长时间、大规模的模糊测试。无论是与 Black-Widow 这类黑盒测试工具，还是 WebFuzz 这类灰盒测试工具集成，它都能显著提升吞吐量和代码覆盖率，因此在需要高效遍历应用状态空间的安全审计和漏洞挖掘场景中价值尤为突出。

​	未来的研究可以聚焦于三个方面进行改进：

1. 当前的表级粒度缓存失效策略虽高效但略显粗糙，未来可探索基于更精细的查询依赖分析或行级粒度的失效机制，以进一步提高缓存命中率；
2. 可将缓存对象从现有的数据库和网络数据，扩展至模板渲染结果、文件系统 I/O 等更多开销较大的资源，从而拓宽性能优化的边界；
3. 鉴于该缓存优化思想的普适性，可将其实现从 PHP 生态系统迁移至 Node.js、Python 等其他主流 Web 开发语言，以适应更广泛的动态应用测试。

通过学习这篇优秀的工作，有以下几点收获：

1. **新idea的提出**，需要建立在对系统运行机制的深度理解之上，从而发现其中可以优化/改进的地方。在这之中，可以大量借鉴已有工具，如XHProf可以实现对函数级别的性能统计，精准量化影响fuzz效率的原因。
2. **实验设计的高度严谨性**，通过构建 基础验证 - 漏洞测试 - 实景应用 三层递进的测试体系，有效规避了单一场景下结论的局限性，实现了对方案从 “功能有效性” 到 “实际应用价值” 的全方位、逐层验证，令人信服。
3. **适配性创新与整合**，借鉴 OPCache 的进程间共享内存设计，且针对模糊测试场景提出了专属的缓存结构，解决了 PHP 请求隔离导致的缓存复用难题，从而实现 “**兼容现有生态**” 与 “**突破性能瓶颈**” 的双重价值。



